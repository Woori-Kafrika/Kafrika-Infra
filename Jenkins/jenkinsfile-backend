pipeline {
  agent any

  options {
    timestamps()
    buildDiscarder(logRotator(numToKeepStr: '10'))
    skipDefaultCheckout(false)
  }

  environment {
    SONAR_TOKEN = credentials('sonar-token')
    SONAR_HOST_URL = 'http://localhost:9000'
    DOCKER_REGISTRY = 'localhost:5001'
    IMAGE_NAME = 'kafrika-backend'
    IMAGE_TAG = "${env.BUILD_NUMBER}"
    ARGOCD_SERVER = 'localhost:8080'
    ARGOCD_TOKEN = credentials('argocd-token')
  }

  stages {
    stage('Checkout') {
      steps {
        checkout scm
      }
    }

    stage('Check Java') {
      steps {
        sh 'echo "JAVA_HOME=$JAVA_HOME"'
        sh 'java -version'
      }
    }

    stage('Prepare') {
      steps {
        sh 'chmod +x gradlew'
      }
    }

    stage('Build') {
      steps {
        sh './gradlew clean build --no-daemon'
      }
    }

    stage('Test') {
      steps {
        sh './gradlew test jacocoTestReport --no-daemon'
      }
    }

    stage('SonarQube Analysis') {
      steps {
        withSonarQubeEnv('SonarQube') {
          sh '''
            ./gradlew sonarqube \
              -Dsonar.projectKey=kafrika-backend \
              -Dsonar.projectName="Kafrika Backend" \
              -Dsonar.projectVersion=1.0 \
              -Dsonar.sources=src/main/java \
              -Dsonar.tests=src/test/java \
              -Dsonar.java.binaries=build/classes \
              -Dsonar.java.test.binaries=build/test-classes \
              -Dsonar.coverage.jacoco.xmlReportPaths=build/reports/jacoco/test/jacocoTestReport.xml \
              -Dsonar.host.url=''' + env.SONAR_HOST_URL + ''' \
              -Dsonar.login=''' + env.SONAR_TOKEN + '''
          '''
        }
      }
    }

    stage('Quality Gate') {
      steps {
        timeout(time: 1, unit: 'MINUTES') {
          waitForQualityGate abortPipeline: true
        }
      }
    }

    stage('Docker Build') {
      steps {
        script {
          sh '''
            docker build -t ${DOCKER_REGISTRY}/${IMAGE_NAME}:${IMAGE_TAG} .
            docker tag ${DOCKER_REGISTRY}/${IMAGE_NAME}:${IMAGE_TAG} ${DOCKER_REGISTRY}/${IMAGE_NAME}:latest
          '''
        }
      }
    }

    stage('Docker Push') {
      steps {
        script {
          sh '''
            docker push ${DOCKER_REGISTRY}/${IMAGE_NAME}:${IMAGE_TAG}
            docker push ${DOCKER_REGISTRY}/${IMAGE_NAME}:latest
          '''
        }
      }
    }

    stage('Update Kubernetes Manifests') {
      steps {
        script {
          sh '''
            # Update deployment.yaml with new image tag
            sed -i 's|image: localhost:5000/kafrika-backend:latest|image: localhost:5000/kafrika-backend:${IMAGE_TAG}|g' k8s/deployment.yaml
            
            # Commit and push changes
            git config user.email "jenkins@example.com"
            git config user.name "Jenkins"
            git add k8s/deployment.yaml
            git commit -m "Update image tag to ${IMAGE_TAG}" || true
            git push origin HEAD:main || true
          '''
        }
      }
    }

    stage('Deploy to Kubernetes') {
      steps {
        script {
          sh '''
            # Wait for ArgoCD to sync (optional)
            echo "Waiting for ArgoCD to sync..."
            sleep 30
            
            # Check deployment status
            kubectl get pods -l app=kafrika-backend -n default
          '''
        }
      }
    }

    stage('Archive Artifacts') {
      steps {
        archiveArtifacts artifacts: 'build/libs/*.jar', fingerprint: true
      }
    }
  }

  post {
    always {
      echo "Build finished: ${currentBuild.currentResult}"
      
      // Cleanup Docker images
      sh '''
        docker rmi ${DOCKER_REGISTRY}/${IMAGE_NAME}:${IMAGE_TAG} || true
        docker rmi ${DOCKER_REGISTRY}/${IMAGE_NAME}:latest || true
      '''
    }
    success {
      echo "‚úÖ CI/CD ÌååÏù¥ÌîÑÎùºÏù∏ ÏÑ±Í≥µ!"
      echo "üöÄ Ïï†ÌîåÎ¶¨ÏºÄÏù¥ÏÖòÏù¥ KubernetesÏóê Î∞∞Ìè¨ÎêòÏóàÏäµÎãàÎã§."
    }
    failure {
      echo "‚ùå CI/CD ÌååÏù¥ÌîÑÎùºÏù∏ Ïã§Ìå®!"
    }
  }
} 