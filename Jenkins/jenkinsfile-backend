pipeline {
  agent any
  
  options {
    buildDiscarder(logRotator(numToKeepStr: '10'))
    skipDefaultCheckout(false)
    timeout(time: 30, unit: 'MINUTES')
  }
  
  environment {
    SONAR_TOKEN = credentials('sonar-token')
    SONAR_HOST_URL = 'http://sonarqube-local:9000'
    DOCKER_REGISTRY = 'docker-registry-local:5000'
    IMAGE_NAME = 'kafrika-backend'
    IMAGE_TAG = "${env.BUILD_NUMBER}"
    ARGOCD_SERVER = 'localhost:8080'
    ARGOCD_TOKEN = credentials('argocd-token')
    
    GRADLE_OPTS = '-Dorg.gradle.daemon=false -Dorg.gradle.caching=false'
    DOCKER_BUILDKIT = '1'
  }
  
  stages {
    stage('Checkout') {
      steps {
        checkout scm
        sh 'ls -la'
        sh 'pwd'
      }
    }
    
    stage('Environment Check') {
      parallel {
        stage('Check Java') {
          steps {
            sh 'echo "JAVA_HOME=$JAVA_HOME"'
            sh 'java -version'
          }
        }
        stage('Check Docker') {
          steps {
            sh 'docker --version'
            sh 'docker info'
          }
        }
        stage('Check Network') {
          steps {
            // ping ÎåÄÏã† curlÏù¥ÎÇò nc ÏÇ¨Ïö©
            sh 'curl -f http://sonarqube-local:9000/api/system/status || echo "SonarQube not reachable"'
            sh 'curl -f http://docker-registry-local:5000/v2/ || echo "Registry not reachable"'
          }
        }
      }
    }
    
    stage('Prepare') {
      steps {
        // gradlew Í∂åÌïú ÏÑ§Ï†ï
        sh 'chmod +x gradlew'
        sh 'echo "Gradle version:"'
        sh './gradlew --version'
        sh './gradlew dependencies --no-daemon'
      }
    }
    
    stage('Build & Test') {
      parallel {
        stage('Build') {
          steps {
            sh './gradlew clean build -x test --no-daemon'
            archiveArtifacts artifacts: 'build/libs/*.jar', fingerprint: true, allowEmptyArchive: true
          }
        }
        stage('Unit Tests') {
          steps {
            sh './gradlew test jacocoTestReport --no-daemon'
          }
          post {
            always {
              // Ï°∞Í±¥Î∂ÄÎ°ú ÌÖåÏä§Ìä∏ Í≤∞Í≥º Î∞úÌñâ
              script {
                if (fileExists('build/test-results/test/*.xml')) {
                  publishTestResults testResultsPattern: 'build/test-results/test/*.xml'
                }
                if (fileExists('build/reports/jacoco/test/jacocoTestReport.xml')) {
                  publishCoverage adapters: [jacocoAdapter('build/reports/jacoco/test/jacocoTestReport.xml')], sourceFileResolver: sourceFiles('STORE_LAST_BUILD')
                }
              }
            }
          }
        }
      }
    }
    
    stage('Code Quality') {
      when {
        expression { 
          return env.SONAR_TOKEN != null && env.SONAR_TOKEN != 'dummy-token'
        }
      }
      steps {
        withSonarQubeEnv('SonarQube') {
          sh """
            ./gradlew sonarqube \
              -Dsonar.projectKey=kafrika-backend \
              -Dsonar.projectName="Kafrika Backend" \
              -Dsonar.projectVersion=${env.BUILD_NUMBER} \
              -Dsonar.sources=src/main/java \
              -Dsonar.tests=src/test/java \
              -Dsonar.java.binaries=build/classes \
              -Dsonar.java.test.binaries=build/test-classes \
              -Dsonar.coverage.jacoco.xmlReportPaths=build/reports/jacoco/test/jacocoTestReport.xml \
              -Dsonar.host.url=$SONAR_HOST_URL \
              -Dsonar.login=$SONAR_TOKEN \
              --no-daemon
          """
        }
      }
    }
    
    stage('Quality Gate') {
      when {
        expression { 
          return env.SONAR_TOKEN != null && env.SONAR_TOKEN != 'dummy-token'
        }
      }
      steps {
        timeout(time: 5, unit: 'MINUTES') {
          waitForQualityGate abortPipeline: false
        }
      }
    }
    
    stage('Security Scan') {
      steps {
        sh './gradlew dependencyCheckAnalyze --no-daemon || true'
      }
      post {
        always {
          archiveArtifacts artifacts: 'build/reports/dependency-check-report.html', allowEmptyArchive: true
        }
      }
    }
    
    stage('Docker Operations') {
      stages {
        stage('Docker Build') {
          steps {
            script {
              sh """
                docker build \
                  --build-arg BUILD_DATE=\$(date -u +'%Y-%m-%dT%H:%M:%SZ') \
                  --build-arg VCS_REF=\$(git rev-parse HEAD) \
                  --build-arg VERSION=${IMAGE_TAG} \
                  -t ${DOCKER_REGISTRY}/${IMAGE_NAME}:${IMAGE_TAG} \
                  -t ${DOCKER_REGISTRY}/${IMAGE_NAME}:latest \
                  .
              """
            }
          }
        }
        
        stage('Docker Security Scan') {
          steps {
            sh """
              docker run --rm -v /var/run/docker.sock:/var/run/docker.sock \
                -v \$(pwd):/tmp/.trivy \
                aquasec/trivy:latest image \
                --exit-code 0 \
                --severity HIGH,CRITICAL \
                --format table \
                ${DOCKER_REGISTRY}/${IMAGE_NAME}:${IMAGE_TAG} || true
            """
          }
        }
        
        stage('Docker Push') {
          steps {
            retry(3) {
              sh """
                docker push ${DOCKER_REGISTRY}/${IMAGE_NAME}:${IMAGE_TAG}
                docker push ${DOCKER_REGISTRY}/${IMAGE_NAME}:latest
              """
            }
          }
        }
      }
    }
    
    stage('GitOps Update') {
      steps {
        script {
          sh """
            if [ -f k8s/deployment.yaml ]; then
              cp k8s/deployment.yaml k8s/deployment.yaml.backup
              
              sed -i 's|image: ${DOCKER_REGISTRY}/${IMAGE_NAME}:.*|image: ${DOCKER_REGISTRY}/${IMAGE_NAME}:${IMAGE_TAG}|g' k8s/deployment.yaml
              
              grep "image: ${DOCKER_REGISTRY}/${IMAGE_NAME}:${IMAGE_TAG}" k8s/deployment.yaml || echo "Image update failed"
              
              git config user.email "jenkins@company.com"
              git config user.name "Jenkins CI"
              
              if ! git diff --quiet k8s/deployment.yaml; then
                git add k8s/deployment.yaml
                git commit -m "üöÄ Deploy kafrika-backend:${IMAGE_TAG} [skip ci]"
                git push origin HEAD:main || echo "Git push failed"
                echo "‚úÖ GitOps repository updated successfully"
              else
                echo "‚ÑπÔ∏è  No changes to commit"
              fi
            else
              echo "‚ö†Ô∏è  k8s/deployment.yaml not found, skipping GitOps update"
            fi
          """
        }
      }
    }
    
    stage('Deploy to Kubernetes') {
      when {
        expression {
          return env.ARGOCD_TOKEN != null && env.ARGOCD_TOKEN != 'dummy-token'
        }
      }
      steps {
        script {
          sh """
            echo "üöÄ Triggering ArgoCD sync for kafrika-backend..."
            
            argocd app sync kafrika-backend \
              --auth-token \$ARGOCD_TOKEN \
              --server \$ARGOCD_SERVER \
              --insecure \
              --timeout 300 || echo "ArgoCD sync failed"
            
            argocd app wait kafrika-backend \
              --auth-token \$ARGOCD_TOKEN \
              --server \$ARGOCD_SERVER \
              --insecure \
              --timeout 600 \
              --health || echo "ArgoCD wait failed"
            
            argocd app get kafrika-backend \
              --auth-token \$ARGOCD_TOKEN \
              --server \$ARGOCD_SERVER \
              --insecure || echo "ArgoCD get failed"
          """
        }
      }
    }
    
    stage('Post-Deploy Verification') {
      when {
        expression {
          return sh(script: 'which kubectl', returnStatus: true) == 0
        }
      }
      steps {
        script {
          sh """
            echo "üîç Running post-deployment verification..."
            
            kubectl wait --for=condition=ready pod -l app=kafrika-backend --timeout=300s || echo "kubectl wait failed"
            
            kubectl get deployment kafrika-backend -o wide || echo "No kafrika-backend deployment found"
            kubectl get pods -l app=kafrika-backend || echo "No kafrika-backend pods found"
          """
        }
      }
    }
  }
  
  post {
    always {
      echo "üèÅ Build finished: ${currentBuild.currentResult}"
      
      sh """
        docker rmi ${env.DOCKER_REGISTRY}/${env.IMAGE_NAME}:${env.IMAGE_TAG} || true
        docker rmi ${env.DOCKER_REGISTRY}/${env.IMAGE_NAME}:latest || true
        docker system prune -f || true
      """
      
      archiveArtifacts artifacts: 'build/reports/**/*', allowEmptyArchive: true
      
      // cleanWs ÎåÄÏã† ÏàòÎèôÏúºÎ°ú Ï†ïÎ¶¨
      sh 'rm -rf build/tmp/* || true'
    }
    
    success {
      echo "‚úÖ CI/CD ÌååÏù¥ÌîÑÎùºÏù∏ ÏÑ±Í≥µ!"
      echo "üöÄ kafrika-backend:${env.IMAGE_TAG} Ïù¥ ÏÑ±Í≥µÏ†ÅÏúºÎ°ú Ï≤òÎ¶¨ÎêòÏóàÏäµÎãàÎã§."
    }
    
    failure {
      echo "‚ùå CI/CD ÌååÏù¥ÌîÑÎùºÏù∏ Ïã§Ìå®!"
      echo "üîç Î°úÍ∑∏Î•º ÌôïÏù∏ÌïòÏó¨ Î¨∏Ï†úÎ•º Ìï¥Í≤∞ÌïòÏÑ∏Ïöî: ${env.BUILD_URL}"
      
      script {
        if (env.ARGOCD_TOKEN != null && env.ARGOCD_TOKEN != 'dummy-token') {
          try {
            sh """
              echo "üîÑ Attempting rollback..."
              argocd app rollback kafrika-backend \
                --auth-token \$ARGOCD_TOKEN \
                --server \$ARGOCD_SERVER \
                --insecure || echo "Rollback failed"
            """
          } catch (Exception e) {
            echo "‚ö†Ô∏è  Rollback failed: ${e.getMessage()}"
          }
        }
      }
    }
    
    unstable {
      echo "‚ö†Ô∏è  ÎπåÎìúÍ∞Ä Î∂àÏïàÏ†ïÌï©ÎãàÎã§. ÌÖåÏä§Ìä∏ Í≤∞Í≥ºÎ•º ÌôïÏù∏ÌïòÏÑ∏Ïöî."
    }
  }
}